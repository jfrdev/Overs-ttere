\documentclass[a4paper, 10pt]{article}
\usepackage[danish]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm,amsfonts,ulem}
\usepackage{courier, fourier}
\usepackage[parfill]{parskip}
\usepackage{float}

\widowpenalty=1000
\clubpenalty=1000

\newcommand{\ra}[0]{\rightarrow}

\author{Henrik Bendt \\ Jens Fredskov \\ Martin Jørgensen}
\title{Oversættere: G-opgaven}
\date{\today}

\begin{document}
\maketitle
\pagebreak

\section{Indledning}
%TODO skriv noget klogt

\section{Lexer}
I lexeren har vi implementeret regulære udtryk der fanger følgende elementer:
char-typen, while-løkker, referencer, dereferencer, opslag, streng- og tegnkonstanter,
lighedsoperatoren og blokke.

Typen char er implementeret ved blot at tilføje dette som et nøgleord i den
eksisterende keyword-funktionen. Dette samme gælder for løkker hvor while blot
er tilføjet som et nøgleord (Det vil så være op til parseren, at sikre, at hvad
der kommer efter er gyldigt).

Referencer og dereferencer er ikke decideret implementeret i lexeren. I stedet
matches på * som så gives videre til parseren som en terminal. Denne kan så
der stå forskelligt afhængigt af om den bruges til en reference eller en
dereference.

Opslag matches ikke i lexeren som et enkelt regulært udtryk, men som to udtryk
der matcher ``['' og ``]''. Disse gives videre til parseren.

For både streng- og tegnkonstanter er der lavet nye eksterne funktioner (hhv.
string og character). De eksterne funktioner konvertere fra C-strenge til
SML-strenge (vha. fromCString). Hvis dette fejler kastes en lexerError. Bemærk
at der inden konverteringen er fjernet de tegn som omgiver en streng- eller
tegnkonstant, altså '$\ldots$' og "$\ldots$". Slutteligt sørger der
regulære udtryk til hver af de to at en del ugyldige strenge og tegn sorteret
fra, ved kun at tage imod tegn mellem 32-126 i ASCII eller escape-sekvenser.
%TODO dette kan godt formuleres pænere og udpensles mere.

Lighedsoperatoren er blot et match på ``==''.

Blokke gøres ligesom opslag, i det der matches på ``\{'' og ``\}''. Disse gives
så som terminaler til parseren.

\section{Parser}
I parseren har vi implementeret følgende regler:
\begin{align*}
    \textit{Type}  & \ra \textbf{Char} \\
    \textit{Sid}   & \ra \textbf{Ref Id} \\
    \textit{Stat}  & \ra \textbf{While Lpar} \textit{ Exp } \textbf{Rpar}
                         \textit{Stat} \\
    \textit{Stat}  & \ra \textbf{Lblock} \textit{ Decs1 Stats } \textbf{Rblock} \\
    \textit{Stats} & \ra \textit{Stat Stats} \\
    \textit{Exp}   & \ra \textbf{StringConst} \\
    \textit{Exp}   & \ra \textbf{CharConst} \\
    \textit{Exp}   & \ra \textit{Lval} \textbf{ Assign } \textit{Exp} \\
    \textit{Lval}  & \ra \textbf{Id Ref} \\
    \textit{Lval}  & \ra \textbf{Id Lbracket} \textit{ Exp } \textbf{Rbracket}
\end{align*}

Her er terminaler givet i fed og nonterminaler i kursiv. Generelt er strukturen
fra den abstrakte syntaks fuldt, og intet er blevet ændret i denne ifm.
implementation af parseren.

%TODO noget om de forskellige nonterminaler og hvorfor de er lavet som de er.
%TODO noget om tests? og hvorfor der ikke er shift-reduces

En ting vi bemærkede ifm. test af parseren, var at der steder i det parsede fra
SeeSyntax.sml stod en # i stedet for den del af strukturen som burde have været
der. Dette viste sig dog at hænge sammen med, at SeeSyntax ikke kan vise
strukturen hvis indlejringen bliver for dyb.

\section{Typechecker}
% Hvad har vi implementeret?
% Hvordan er typer lavet
% hvad har vi ændret markant, og hvilke funktioner har vi tilføjet

% Særdeles spændende er return check :P

% Vi har fortolket således at man godt kan gøre følgende
% char *x; x* = 'a' + 1

\section{Oversætter}

\subsection{Generelt}
Vi har tilføjet en konstant \textit{ZERO}, der repræsentere registeret 0. Dette
er for symbolsk overskud i koden (kende forskel på imidiate og registre).


\subsection{compileExp}


\subsection{While-løkke}

\subsection{Block}
Funktionen \texttt{makeVtable} laver og returnere et nyt vtable'. Blokken
hægter derpå vtable' foran det gamle vtable, og kalder \texttt{compileStat} med
denne. Derudover kaldes \texttt{RegAlloc} til at allokere registre til de nye
variable.

Da vtable er hægtet bagpå vtable', vil variable i vtable automatisk bevare
sine værdier efter blokken, om de er blevet tilskrevet nye værdier eller ej,
idet variable, som ikke er erklæret igen indenfor blokken, stadig tilgås via
vtable og derfor tilgås de samme registre.

Når blokken slutter, bliver vtable' ikke brugt mere (i og med det ikke er givet
videre til nogen efterfølgende erklæringer), og vil derfor automatisk blive
fjernet af spildopsamleren.

\textit{StringConst} er en tegnreference, som først trækker længden af strengen
plus et endeelement (nullbyte) fra stakpegeren og derpå bruger ASCIIZ til at
lægge strengen på stakken (over stakpegeren).

\textit{Assaign} patternmatcher på int, ref(int) og ref(char) i sidste instans,
idet de alle skal håndteres ens. Resten håndteres enkeltvis, idet de
henholdsvis er en tegnkonstant, der skal tjekkes på 8 bit, en tegnkonstant
der tilgår stakken på 8 bit og en heltalsværdi der også tilgår
stakken, men på 32 bit.

\subsection{Behandling af tegnkonstanter}
Vi har tilføjet en funktion \texttt{makeCharConst}, der omdanner en
sml-tegnkonstant til en C-strengstegnkonstant der kan behandles af Mars
(singlequotes bibeholdes i strengen).

Da 100 tillader at addere tegnkonstant med tal og lade output være en
tegnkonstant, kan man ``hacke'' sproget, idet man kan tilgå de tegn, som ellers
ikke er tilladt (og bliver tjekket for i lexeren). Dette er ikke noget vi har
valgt at behandle, idet programmøren selv må bære ansvaret, når han blander tal
og tegnkonstanter. Det kan dog resultere i et program, der giver en
uspecificerede opførsel.

I compileExp, når en tegnkonstant evalueres, sørges for, at kun de første 8 ud
af 32 bit bliver sat, ved at kalde MIPS-instruktionen andi på registeret med
sig selv og konstanten 255. 

\subsection{Lval}
Vi tilføjede dereference og opslag, som begge tilgår stakken. Derfor valgte vi
at udvide datatypen \textbf{Location} med en \textbf{Mem}. Dette gør, at når en
dereference eller et opslag (beskrevet i \texttt{compileLval}) tilgår stakken 
for at hente en værdi, i stedet for at gemme værdien i et midlertidigt
register, bliver værdien gemt direkte i det tiltænkte register. Derved spares et
register, for hvis vi brugte datatypen \textbf{Reg}, ville \texttt{compileLval}
hente værdien fra stakken til et midlertidigt register, for at \texttt{lval}
efterfølgende kan flytte værdien fra dette register til det tiltænkte register.

Ved opslag bruges dog et midlertidigt register til at holde den nye adresse
(inkl. offset) til stakken, som gives til \texttt{lval}, der gemmer værdien i
det tiltænkte register.

Når en tegnkonstant hentes, sørges samtidig for, i \texttt{lval}, at kun de
første 8 ud af 32 bits i registeret sættes (til tegnkonstanten), hvor resten
sættes til 0. Dette sikre at gamle data i registeret ikke er tilgængelige.

\section{Konklusion}
% overall hvad virker hvad gør ikke!
\end{document}
